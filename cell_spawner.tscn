[gd_scene load_steps=5 format=3 uid="uid://diimhw6lk5yth"]

[ext_resource type="StyleBox" uid="uid://ceqgrmyodgbcj" path="res://StyleBoxSpawner.tres" id="1_5ipqg"]
[ext_resource type="PackedScene" uid="uid://btubenec55x0o" path="res://cell.tscn" id="1_y6xxv"]

[sub_resource type="GDScript" id="GDScript_p5304"]
script/source = "extends Button

@export var cell : PackedScene
@export var center : CenterContainer
@export var area_2d : Area2D

var cells = [] 
var spawner_owner := -1 : #who currently is the owner of this spawner, -1 if there is no owner
	set(value):
		spawner_owner = value
		change_color(spawner_owner)

var spawner_type : String #based on the spawner types[\"Inner\", \"Sides\", \"Edge\"], it will have few cells needed until it pops
var spawner_directions : Array[Vector2] :#where cells can go when it pops, to avoid cells going out of grid
	set(value):
		spawner_directions = value
		if spawner_directions.size() == 2:
			spawner_type = \"Edge\"
		elif spawner_directions.size() == 3:
			spawner_type = \"Side\"
		else:
			spawner_type = \"Inner\"

func _on_pressed() -> void:
	if spawner_owner == -1: #if no owner of this spawner, 
		spawner_owner = PlayerData.current_player #assign the current player as the owner

	if spawner_owner == PlayerData.current_player: #if there is an owner and the current player is the owner
		check_cells() #add a cell to account for the press
		PlayerData.current_player = PlayerData.current_player + 1 #switch to the next player in queue

func spawn_cell():
	var cell_instance = cell.instantiate() #create an instance of the cell
	center.call_deferred(\"add_child\", cell_instance) #add the cell as a child of the center(to spawn to center)
	cells.append(cell_instance) #append to the cells array
	
	cell_instance.change_color(spawner_owner)
	cell_instance.connect(\"tree_exited\", set_monitoring_true) #attach an auto connect to the cell, to set monitoring to true once the cell is deleted
	
	for i in cells.size(): #change cell's shake based on the amount of cells
		cells[i].change_shake(cells.size() * 0.15)
		cells[i].change_intensity(cells.size() * 0.15)
	
	PlayerData.calculate_cell_count(spawner_owner, 1) #change the player's cell count by +1 since spawning

func check_cells(): #check how many cells you have and either add or pop
	if spawner_directions.is_empty(): #if this spawner doesnt have directions yet(directions that the cells can go when it pops)
		spawner_directions = get_parent().get_available_directions(position) #get available directions

	if cells.size() < spawner_directions.size() - 1: #check if the directions have not been met
		spawn_cell()  
	else: #else pop a chain reaction where each cell has a direction to go to
		pop()

func pop(): #launch the cells in adjacent directions
	set_monitoring_false() #turn off monitoring to not detect your own cells
	spawn_cell() #add the last cell before it pops
	for i in spawner_directions.size(): #iterate through each cell
		cells[i].pop(spawner_directions[i]) #iterated cell goes through the iterated directions
		PlayerData.calculate_cell_count(spawner_owner, -1) #remove cell count on the player -1 for each cells since they're now popped
	cells.clear() #clear the array of cells
	spawner_owner = -1 #since there are no more cells in this spawner means there are no owners

func _on_area_2d_body_entered(body: Node2D) -> void: #when something enters this spawner
	if body.is_in_group(\"Cell\"): #Check if a cell enters
		body.queue_free() #if it's a cell remove that cell
		
		PlayerData.calculate_cell_count(spawner_owner, -(cells.size())) #reduce the last owner's cell count by the amount of cells that was converted
		spawner_owner = PlayerData.previous_player #change the owner of this spawner to the player that infected this spawner
		PlayerData.calculate_cell_count(spawner_owner, +(cells.size())) #increase the new owner's cell count by the amount of cells that was converted
		
		change_color(spawner_owner) #change the cell color based on the new owner's cell color
		check_cells() #add a cell to account for the cell that just entered but deleted after

func change_color(spawner_owner : int): #replace the cell color of children cells(everytime another owner infects this cell)
	for i in cells.size():
		cells[i].change_color(spawner_owner)

func set_monitoring_false(): #set monitoring to false to stop detecting for any cells
	area_2d.set_deferred(\"monitoring\", false)

func set_monitoring_true(): #set monitoring to true, for the auto connect and to detect cells
	area_2d.set_deferred(\"monitoring\", true)
"

[sub_resource type="CircleShape2D" id="CircleShape2D_1wp5y"]
radius = 32.0

[node name="Cell_spawner" type="Button" node_paths=PackedStringArray("center", "area_2d")]
custom_minimum_size = Vector2(96, 96)
offset_left = -48.0
offset_top = -48.0
offset_right = 48.0
offset_bottom = 48.0
pivot_offset = Vector2(48, 48)
size_flags_horizontal = 4
size_flags_vertical = 4
focus_mode = 0
theme_override_styles/normal = ExtResource("1_5ipqg")
script = SubResource("GDScript_p5304")
cell = ExtResource("1_y6xxv")
center = NodePath("CenterContainer")
area_2d = NodePath("CenterContainer/Area2D")
metadata/_edit_use_anchors_ = true

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
grow_horizontal = 2
grow_vertical = 2
use_top_left = true

[node name="Area2D" type="Area2D" parent="CenterContainer"]
collision_layer = 0
collision_mask = 2

[node name="CollisionShape2D" type="CollisionShape2D" parent="CenterContainer/Area2D"]
shape = SubResource("CircleShape2D_1wp5y")

[connection signal="pressed" from="." to="." method="_on_pressed"]
[connection signal="body_entered" from="CenterContainer/Area2D" to="." method="_on_area_2d_body_entered"]
